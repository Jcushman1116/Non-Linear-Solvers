% Task 2.1: Three Distinct Roots 
% Cubic Polynomial: f(x) = x(x-p)(x+p) with roots: 0, p>0, and -p

% Dertivative f'(x) = 3(x-a)(x+a) with roots: a = p/sqrt(3) > 0

% Analyze Newtons method for 
    % case a): x > p
    % case b): a < x < p 
    % case c): -c < x < c where c is the "cycling point for f(x)"

m = 1; % Standard Newton 
p = 2; %starting point 
num_trials = 10; 

% Case Variables:
x_guess1 = 4; % x>p
x_guess2 = 1.5 ; % alpha < x < p 
x_guess3 = 0.5; % -c < x < c where c is the cycling point

% what is the value of c = p/sqrt(5) from solving Phi(x) = -x
alpha = p/sqrt(3);  
% Define the function 

f = @(x) x*(x-p)*(x+p); 
df = @(x) 3*(x-alpha)*(x+alpha);

% Question 1: Demonstrate the 3 cases 

% Case 1 Function Call
fprintf("Newton behavior on the Interval: x > p \n"); 
[case1_root, progress1, iterations1] = Newtons_Method(f,df,x_guess1,m,num_trials);
fprintf("root: %f |  Iterations: %d \n: ", case1_root , iterations1); 
disp(progress1)

%Case 2 Function Call
fprintf("Newton behavior on the Interval: a < x < p \n"); 
[case2_root, progress2, iterations2] = Newtons_Method(f, df, x_guess2, m, num_trials);
fprintf("root: %f |  Iterations: %d \n ", case2_root, iterations2);
disp(progress2)

% Case 3 Function Call
fprintf("Newton behavior on the Interval: -c < x < c \n"); 
[case3_root, progress3, iterations3] = Newtons_Method(f, df, x_guess3, m, num_trials);
fprintf("root: %f |  Iterations: %d \n", case3_root, iterations3);
disp(progress3)

% Question 2: What happens when x0 is the floating point rep of c

x_cycle = p/sqrt(5); % derived

fprintf("Newton behavior for x0 = c (cycling point) \n"); 
[case4_root, progress4, iterations4] = Newtons_Method(f, df, x_cycle, m, num_trials);
fprintf("root: %f |  Iterations: %d \n", case4_root, iterations4);
disp(progress4)

% What if we perturb the cycling point 
% Perturb the cycling point slightly

fprintf("Newton Bahvior for Perturbed cycling point: x0 + eps \n")
for n=1:10 % Makes each purtubation smaller % can go higher than 10 i think 
    pertubation = (1/10)^n; % .1, .01, .001, ...
    x_cycle_perturbed = x_cycle + pertubation; 
    [case5_root, progress5, iterations5] = Newtons_Method(f, df, x_cycle_perturbed, m, num_trials);
    fprintf("pertubation size: %.10f | root after perturbation: %f |  Iterations: %d \n", pertubation, case5_root, iterations5);
    disp(progress5);
end 

fprintf("Newton Bahvior for Perturbed cycling point: x0 - eps \n")
for n=1:10 % Makes each purtubation smaller % can go higher than 10 i think 
    pertubation = (1/10)^n; % .1, .01, .001, ...
    x_cycle_perturbed = x_cycle - pertubation; 
    [case6_root, progress6, iterations6] = Newtons_Method(f, df, x_cycle_perturbed, m, num_trials);
    fprintf("pertubation size: %.10f | root after perturbation: %f |  Iterations: %d \n", pertubation, case6_root, iterations6);
    disp(progress6);
end 

% 3) skipped for now 

% 4) can we make newton method fail by producing numbers too large

% first let the initial guess be the largest possible 
% double precision floating number 

fprintf("Newton Behavior for Largest Double precision float: \n"); 
x_realmax_double = realmax('double'); %realmax is largest double prec num
[case7_root, progress7, iterations7] = Newtons_Method(f, df, x_realmax_double, m, num_trials);
fprintf("Root: %.10f | Iterations: %d \n", case7_root, iterations7);
disp(progress7);

fprintf("Newton Behavior for Largest Single precision float: \n"); 
x_realmax_single = realmax('single'); %realmax is largest double prec num
[case8_root, progress8, iterations8] = Newtons_Method(f, df, x_realmax_single, m, num_trials);
fprintf("Root: %.10f | Iterations: %d \n", case8_root, iterations8);
disp(progress8);

% Thus showing a counterexample for when newtons method fails due to a
% large starting point, AKA realmax in Matlab 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Testing Steffenson Method: Uses the same information as Newtons Methods


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Next we will compare the Other iterative methods 
% Regula Falsi: 

fprintf("Regula Falsi Testing \n")

% Recall roots at -2,0,2
a = -3; 
b = -1; 
fprintf("Test Interval 1: ")
disp([a,b])

[case9_root, progress9, iterations9] = RegulaFalsi_Method(f, a, b ,num_trials); 
fprintf("Regula Falsi Root: %f | Iterations: %d \n", case9_root, iterations9);
disp(progress9);

a = -1; 
b = 1;
fprintf("Test Interval 2: ")
disp([a,b])

[case10_root, progress10, iterations10] = RegulaFalsi_Method(f, a, b ,num_trials); 
fprintf("Regula Falsi Root: %f | Iterations: %d \n", case10_root, iterations10);
disp(progress10);

a = 1; 
b = 3; 
fprintf("Test Interval 3: ")
disp([a,b])

[case11_root, progress11, iterations11] = RegulaFalsi_Method(f, a, b, num_trials); 
fprintf("Regula Falsi Root: %f | Iterations: %d \n", case11_root, iterations11);
disp(progress11);

a = -3;
b = 1; 
fprintf("Test Interval 4: ")
disp([a,b])

[case12_root, progress12, iterations12] = RegulaFalsi_Method(f, a, b, num_trials); 
fprintf("Regula Falsi Root: %f | Iterations: %d \n", case12_root, iterations12);
disp(progress12);

a = -1;
b = 3; 
fprintf("Test Interval 5: ")
disp([a,b])

[case13_root, progress13, iterations13] = RegulaFalsi_Method(f, a, b, num_trials); 
fprintf("Regula Falsi Root: %f | Iterations: %d \n", case13_root, iterations13);
disp(progress13);

a = -3; 
b = 3; 
fprintf("Test Interval 6: ")
disp([a,b])

[case14_root, progress14, iterations14] = RegulaFalsi_Method(f, a, b, num_trials); 
fprintf("Regula Falsi Root: %f | Iterations: %d \n", case14_root, iterations14);
disp(progress14);

a = -3; 
b = -4; 
fprintf("Test Interval 7: ")
disp([a,b])

[case15_root, progress15, iterations15] = RegulaFalsi_Method(f, a, b, num_trials); 
fprintf("Regula Falsi Root: %f | Iterations: %d \n", case15_root, iterations15);
disp(progress15);

a = 3; 
b = 4; 
fprintf("Test Interval 8: ")
disp([a,b])

[case16_root, progress16, iterations16] = RegulaFalsi_Method(f, a, b, num_trials); 
fprintf("Regula Falsi Root: %f | Iterations: %d \n", case16_root, iterations16);
disp(progress16);

a = -p/sqrt(5);
b = p/sqrt(5); 
fprintf("Test Interval 8: ")
disp([a,b])

[case17_root, progress17, iterations17] = RegulaFalsi_Method(f, a, b, num_trials); 
fprintf("Regula Falsi Root: %f | Iterations: %d \n", case17_root, iterations17);
disp(progress17);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Secant Testing
% Similar to RF we must choose inervals that may or may not work